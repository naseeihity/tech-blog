---
title: 跨域问题总结
date: 2018-5-24 20:20:22
excerpt: 前端几种常见的跨域问题总结
---

## CORS(Cross-Origin Resource Sharing)
跨域资源共享，支持所有类型的HTTP请求。使用自定义的HTTP头部（包含页面的源信息，协议域名端口等），让浏览器与服务器进行沟通，从而决定请求或响应是否成功。

#### 基本设置
```
//客户端HTTP请求头部
Origin: http://www.gaococ.com
//服务器端头部回发
Access-Control-Allow-Origin: http://www.gaococ.com //允许的源
Access-Control-Allow-Methods: get,post //允许的方法，用逗号隔开
Access-Control-Allow-Headers: //允许的头部
Access-Control-Max-Age: //缓存该请求的时常(s)
```

#### 限制
现代浏览器都通过XHR实现了对CORS的原生支持，但会有以下限制：

不能使用setRequestHeader()设置自定义头部
不能发送和接收cookie
调用getAllResonseHeaders()方法会返回空字符串
由于同源请求和跨域请求使用了相同的接口，所以在访问本地资源时，应尽量使用相对路径，避免产生以上限制。

#### 带凭据的请求
凭据：cooke,HTTP认证，客户端SSL证明等

```js
// 客户端
const xhr = new XMLHttpRequest();
xhr.withCredentials = true;

//服务器端
Access-Control-Allow-Credentials: true
兼容低版本浏览器
利用IE通过XDomainRequest实现跨域：

function createCORSRequest(method, url) {
 let xhr = new XMLHttpRequest();
 if ("withCredentials" in xhr) {
 xhr.open(method, url, true);
 } else if (typeof XDomainRequest !== "undefined") {
 xhr = new XDomainRequest();
 xhr.open(method, url);
 } else {
 xhr = null;
 }
 return xhr;
}

var request = createCORSRequest("get", "http://www.somewhere-else.com/page/");
if (request){
 request.onload = function(){
 //对 request.responseText 进行处理
 };
request.send();
}
<!-- 
 abort() ：用于停止正在进行的请求。
 onerror ：用于替代 onreadystatechange 检测错误。
 onload ：用于替代 onreadystatechange 检测成功。
 responseText ：用于取得响应内容。
 send() ：用于发送请求。 -->
```

## JSONP(JSON with padding)
参数式JSON，因为js并不能直接解析JSON，所以需要将JSON数据以参数的形式传入到函数中。JSONP一般由回调函数和数据组成，利用script标签不受同源条件的限制的原理，通过动态生成script标签的方法，将请求结果传入回调函数中实现跨域请求。但是，JSONP只支持get请求，且其安全性难以控制，以及难以判断请求是否失败。

```js
//客户端实现
function handleResponse(response){
 alert("You’re at IP address " + response.ip + ", which is in " +
 response.city + ", " + response.region_name);
}
var script = document.createElement("script");
script.src = "http://gaococ.com/json/?callback=handleResponse";
document.body.insertBefore(script, document.body.firstChild);
//服务器端
走服务器端的json方法，将其返回值传入handleResponse
```

#### JSONP的安全问题
依然还是CSRF的问题，其防御应该从以下几个方面下手

#### 限制Referer，设置Token
严格按照JSON标准格式输出(Content-Type : application/json; charset=utf-8)
过滤callback函数名，以及里面输出的数据

## postMessage
主要用于向当前页面的iframe，或者由当前页面弹出的窗口传递消息。在父页面（消息发送方）的写法如下：

```js
var iframeWindow = document.getElementById("myframe").contentWindow;
iframeWindow.postMessage("A secret", "http://www.wrox.com");
```
其中postMessage的第一个参数是消息内容的字符串，第二个参数表示消息的接收者必须来自哪个域。

在子页面（消息接收方），通过异步的message事件来监听该消息，并有origin，data，source三个属性，具体写法如下：

```js
EventUtil.addHandler(window, "message", function(event){
 //确保发送消息的域是已知的域
 if (event.origin == "http://www.wrox.com"){
 //处理接收到的数据
 processMessage(event.data);
 //可选:向来源窗口发送回执
 event.source.postMessage("Received!", "http://p2p.wrox.com");
 }
});
```

其中source在同域的情况下，拿到的就是window对象，但大多数情况（跨域）下拿到的都是window对象的代理，通过他并不能访问到window对象的其他信息，一般也只用他调用postMessge方法发送回执信息。

为了浏览器的兼容，postMessage()的地一个参数只传入字符串，如果想传入json数据，可以通过JSON.stringify()进行转换后传递，在接收方使用JSON.parse()再将数据格式化。

## window.name
一个窗口的生命周期内，所有载入的页面都共享一个window.name，他们都对其有读写权限，即使页面刷新还依然存在，还是多配合iframe使用的。下面是一个例子，感觉这个方法还是好蠢，也不知道实际中到底会怎么用。

```
iframe = document.createElement('iframe');
iframe.style.display = 'none';
var state = 0;

iframe.onload = function() {
 if(state === 1) {
 var data = JSON.parse(iframe.contentWindow.name);
 console.log(data);
 iframe.contentWindow.document.write('');
 iframe.contentWindow.close();
 document.body.removeChild(iframe);
 } else if(state === 0) {
 state = 1;
 iframe.contentWindow.location = 'http://localhost:81/cross-domain/proxy.html';
 }
};

iframe.src = 'http://localhost:8080/data.php';
document.body.appendChild(iframe);
```

### Comet(不知道和跨域有什么关系)
一种从服务器端想客户端推送数据的技术，分为长轮询和流两种实现方式。

短轮询 浏览器定时向服务器发起请求，服务器立即给出回应。

长轮询 浏览器向服务器发起请求，并保持HTTP链接，直到服务器响应，然后再发起下一次请求。

HTTP流 在页面的整个生命周期内只有一个HTTP链接，服务器周期性地向浏览器发送数据，浏览器的XHR对象通过判断readyState的值为3来取得更新后的数据。

### Web Sockets
一种持久连接的全双工通信。
#### 优势

服务器可以主动推送消息给客户端(解决http中response必须和request对应的问题)
只需要建立一次HTTP连接(性能上极大提升)
实现原理
在JS中建立Web Socket后，会发送一个HTTP请求，服务器响应后，会将HTTP协议升级为Web Socket协议(即要求服务器同时支持这两种协议)，这样可以减小请求的开销。

对于Web Sockets，未加密的链接为 ws://, 加密的链接为 wss://。

#### 使用
```js
const socket = new WebSocket("ws://www.gaococ.com/server.php");
//同源策略不适用于websocket，必须使用绝对地址

有readyState属性来表示当前状态：
 WebSocket.OPENING (0)：正在建立连接。
 WebSocket.OPEN (1)：已经建立连接。
 WebSocket.CLOSING (2)：正在关闭连接。
 WebSocket.CLOSE (3)：已经关闭连接。

//发送数据
socket.send()//依然只能发送纯字符串数据，JSON需要Stringify。
//关闭连接
socket.close()
//接收数据
socket.onmessage = function(event){
 var data = event.data;
 //处理数据
};
//必须使用DOM0级事件
//onopen 事件，在建立连接时触发
//onerror 事件，发生错误时触发
//onclose 事件，连接关闭时触发
一个典型的WebSocket握手
//客户端
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket 
Connection: Upgrade //请求将协议升级为WebSocket协议
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== //浏览器生产，验证
Sec-WebSocket-Protocol: chat, superchat //用户定义的字符串，区分同URL下不同服务需要的协议
Sec-WebSocket-Version: 13
Origin: http://example.com

//服务器
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade //协议切换成功
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

Socket.IO
他是一个WebSocket库，通过Node.Js实现了服务端基于WebSocket以及其他传输方式的封装，它提供了一个抽象层,以相同的API兼容WebSocket和其他传输方案。同时也提供了客户端的API接口。

